{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 31, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/helpers/getDataFromToken.ts"],"sourcesContent":["// import { NextRequest } from \"next/server\";\n// import jwt from \"jsonwebtoken\";\n// export const getDataFromToken = (request: NextRequest) => {\n//     try {\n//       const token = request.cookies.get(\"token\")?.value || '';\n//       const decodedToken: any = jwt.verify(token, process.env.TOKEN_SECRET!);\n  \n//       // Assuming the token contains both `id` and `role`\n//       return { id: decodedToken.id, role: decodedToken.role, username: decodedToken.username };\n//     } catch (error) {\n//           console.error(\"Error decoding token i dunno why:\", error); // Log detailed error for debugging\n//           throw new Error(error.message || \"Token verification failed\");\n//         }\n//   };\n\nimport { NextRequest } from \"next/server\";\nimport jwt from \"jsonwebtoken\";\n\ninterface DecodedToken {\n  id: string;\n  role: string;\n  username: string;\n  email: string;\n}\n\nexport const getDataFromToken = (request: NextRequest) => {\n  try {\n    console.log(\"Cookies:\", request.cookies); // Log cookies to check structure\n    const token = request.cookies?.get(\"token\")?.value || ''; // Safely access token\n\n    if (!token) throw new Error(\"Token not found\");\n\n    const decodedToken = jwt.verify(token, process.env.JWT_SECRET_KEY!) as DecodedToken;\n    return {\n      id: decodedToken.id,\n      role: decodedToken.role,\n      username: decodedToken.username,\n      email: decodedToken.email,\n    };\n  } catch (error) {\n    console.error(\"Error decoding token i dunno why:\", error); // Log detailed error for debugging\n    throw new Error(error.message || \"Token verification failed\");\n  }\n};\n"],"names":[],"mappings":"AAAA,6CAA6C;AAC7C,kCAAkC;AAClC,8DAA8D;AAC9D,YAAY;AACZ,iEAAiE;AACjE,gFAAgF;AAEhF,4DAA4D;AAC5D,kGAAkG;AAClG,wBAAwB;AACxB,2GAA2G;AAC3G,2EAA2E;AAC3E,YAAY;AACZ,OAAO;;;;AAGP;;AASO,MAAM,mBAAmB,CAAC;IAC/B,IAAI;QACF,QAAQ,GAAG,CAAC,YAAY,QAAQ,OAAO,GAAG,iCAAiC;QAC3E,MAAM,QAAQ,QAAQ,OAAO,EAAE,IAAI,UAAU,SAAS,IAAI,sBAAsB;QAEhF,IAAI,CAAC,OAAO,MAAM,IAAI,MAAM;QAE5B,MAAM,eAAe,qIAAA,CAAA,UAAG,CAAC,MAAM,CAAC,OAAO,QAAQ,GAAG,CAAC,cAAc;QACjE,OAAO;YACL,IAAI,aAAa,EAAE;YACnB,MAAM,aAAa,IAAI;YACvB,UAAU,aAAa,QAAQ;YAC/B,OAAO,aAAa,KAAK;QAC3B;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,qCAAqC,QAAQ,mCAAmC;QAC9F,MAAM,IAAI,MAAM,MAAM,OAAO,IAAI;IACnC;AACF"}},
    {"offset": {"line": 66, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 72, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/config/rolesConfig.ts"],"sourcesContent":["export const rolePaths = {\r\n    Admin: ['/admin', '/dashboard','/user-pages/user/profile', '/campaign/create-campaign'],\r\n    Donor: ['/donor', '/user-pages/user/profile', '/campaign/create-campaign'],\r\n    Organizer: ['/organizer', '/events', '/user-pages/user/profile', '/campaign/create-campaign'],\r\n  };\r\n  "],"names":[],"mappings":";;;AAAO,MAAM,YAAY;IACrB,OAAO;QAAC;QAAU;QAAa;QAA4B;KAA4B;IACvF,OAAO;QAAC;QAAU;QAA4B;KAA4B;IAC1E,WAAW;QAAC;QAAc;QAAW;QAA4B;KAA4B;AAC/F"}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 99, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/middleware.ts"],"sourcesContent":["// // src/middleware.ts\n\n// import { NextResponse } from 'next/server';\n// import type { NextRequest } from 'next/server';\n// import { getDataFromToken } from \"@/helpers/getDataFromToken\";\n\n// export async function middleware(request: NextRequest) {\n//   const path = request.nextUrl.pathname;\n//   const isPublicPath = ['/login', '/signup', '/verifyemail', '/'].includes(path);  // Public routes\n//   const token = request.cookies.get('token')?.value || '';  // Get token from cookies\n\n//   let userRole = '';\n\n//   // Check if token exists and extract user role\n//   if (token) {\n//     try {\n//       const { id, role, username } = await getDataFromToken(request);  // Assuming `getDataFromToken` extracts the role from the token\n//       userRole = role;\n//     } catch (error) {\n//       return NextResponse.redirect(new URL('/login', request.nextUrl));  // Invalid token\n//     }\n//   }\n\n//   // Define role-based access\n//   const rolePaths = {\n//     Admin: ['/admin', '/user', '/dashboard','/user-pages/user/profile','/campaign/create-campaign'],\n//     Donor: ['/user-pages/user/profile', '/dashboard', '/user','/campaign/create-campaign'],\n//     Organizer: ['/organizer', '/user', '/events', '/campaign/create-campaign','/user-pages/user/profile'],\n//   };\n\n//   // Helper function to check if a path is allowed for a particular role\n//   const isAuthorized = (role: string, path: string) => {\n//     return rolePaths[role]?.includes(path) || isPublicPath;\n//   };\n\n//   // Case 1: Redirect logged-in users trying to access public paths\n//   if (isPublicPath && token) {\n//     return NextResponse.redirect(new URL('/', request.nextUrl));  // Redirect authenticated users from public pages to home\n//   }\n\n//   // Case 2: Redirect unauthenticated users trying to access non-public paths\n//   if (!isPublicPath && !token) {\n//     return NextResponse.redirect(new URL('/login', request.nextUrl));  // Redirect unauthenticated users to login page\n//   }\n\n//   // Case 3: Check if the user has permission to access the requested path based on their role\n//   if (token && !isAuthorized(userRole, path)) {\n//     return NextResponse.redirect(new URL('/', request.nextUrl));  // Redirect unauthorized users to the home page (or other appropriate page)\n//   }\n\n//   // Allow the request to continue if everything is valid\n//   return NextResponse.next();\n// }\n\n// // Configuration to match the paths\n// export const config = {\n//   matcher: [\n//     '/', '/user-pages/user/profile', '/login', '/signup', '/verifyemail', \n//     '/admin', '/user', '/organizer', '/events', '/campaign/create-campaign'\n//   ],  // List of paths where the middleware should be applied\n// };\n\n\n\n// import { NextResponse } from 'next/server';\n// import { NextRequest } from 'next/server';\n// import { getDataFromToken } from \"@/helpers/getDataFromToken\";\n// import { rolePaths } from \"@/config/rolesConfig\";\n\n// export async function middleware(request: NextRequest) {\n//   const path = request.nextUrl.pathname;\n//   const isPublicPath = ['/login', '/signup', '/verifyemail', '/'].includes(path); \n//   const token = request.cookies?.get('token')?.value || ''; // Safely access token\n\n//   let userRole = '';\n\n//   if (token) {\n//     try {\n//       const { role } = getDataFromToken(request);  // Pass the entire request to the helper\n//       userRole = role;\n//     } catch (error) {\n//       console.error(\"Error decoding token i know why:\", error);\n//       return NextResponse.redirect(new URL('/login', request.nextUrl));\n//     }\n//   }\n\n//   const isAuthorized = (role: string, path: string) => {\n//     return rolePaths[role]?.includes(path) || isPublicPath;\n//   };\n\n//   if (isPublicPath && token) {\n//     return NextResponse.redirect(new URL(rolePaths[userRole]?.[0] || '/', request.nextUrl));\n//   }\n\n//   if (!isPublicPath && !token) {\n//     return NextResponse.redirect(new URL('/login', request.nextUrl));\n//   }\n\n//   if (token && !isAuthorized(userRole, path)) {\n//     console.warn(`Unauthorized access attempt by role: ${userRole} to path: ${path}`);\n//     return NextResponse.redirect(new URL('/', request.nextUrl));\n//   }\n\n//   return NextResponse.next();\n// }\n\n// export const config = {\n//   matcher: [\n//     '/', '/user-pages/user/profile', '/login', '/signup', '/verifyemail',\n//     '/admin', '/donor', '/organizer', '/events', '/campaign/create-campaign',\n//   ],\n// };\n     "],"names":[],"mappings":"AAAA,uBAAuB;AAEvB,8CAA8C;AAC9C,kDAAkD;AAClD,iEAAiE;AAEjE,2DAA2D;AAC3D,2CAA2C;AAC3C,sGAAsG;AACtG,wFAAwF;AAExF,uBAAuB;AAEvB,mDAAmD;AACnD,iBAAiB;AACjB,YAAY;AACZ,yIAAyI;AACzI,yBAAyB;AACzB,wBAAwB;AACxB,4FAA4F;AAC5F,QAAQ;AACR,MAAM;AAEN,gCAAgC;AAChC,wBAAwB;AACxB,uGAAuG;AACvG,8FAA8F;AAC9F,6GAA6G;AAC7G,OAAO;AAEP,2EAA2E;AAC3E,2DAA2D;AAC3D,8DAA8D;AAC9D,OAAO;AAEP,sEAAsE;AACtE,iCAAiC;AACjC,8HAA8H;AAC9H,MAAM;AAEN,gFAAgF;AAChF,mCAAmC;AACnC,yHAAyH;AACzH,MAAM;AAEN,iGAAiG;AACjG,kDAAkD;AAClD,gJAAgJ;AAChJ,MAAM;AAEN,4DAA4D;AAC5D,gCAAgC;AAChC,IAAI;AAEJ,sCAAsC;AACtC,0BAA0B;AAC1B,eAAe;AACf,6EAA6E;AAC7E,8EAA8E;AAC9E,gEAAgE;AAChE,KAAK;AAIL,8CAA8C;AAC9C,6CAA6C;AAC7C,iEAAiE;AACjE,oDAAoD;AAEpD,2DAA2D;AAC3D,2CAA2C;AAC3C,qFAAqF;AACrF,qFAAqF;AAErF,uBAAuB;AAEvB,iBAAiB;AACjB,YAAY;AACZ,8FAA8F;AAC9F,yBAAyB;AACzB,wBAAwB;AACxB,kEAAkE;AAClE,0EAA0E;AAC1E,QAAQ;AACR,MAAM;AAEN,2DAA2D;AAC3D,8DAA8D;AAC9D,OAAO;AAEP,iCAAiC;AACjC,+FAA+F;AAC/F,MAAM;AAEN,mCAAmC;AACnC,wEAAwE;AACxE,MAAM;AAEN,kDAAkD;AAClD,yFAAyF;AACzF,mEAAmE;AACnE,MAAM;AAEN,gCAAgC;AAChC,IAAI;AAEJ,0BAA0B;AAC1B,eAAe;AACf,4EAA4E;AAC5E,gFAAgF;AAChF,OAAO;AACP,KAAK"}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}